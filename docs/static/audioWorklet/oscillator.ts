interface Oscillator {
    wave: number;
    waveFn: (osc: Oscillator, position: number, cycle: number) => number;
    generatorState: number;
    phase: number;
    value: number;
}

const samplesPerMS = (sampleRate << 8) / 1000;
const toneStepMult = (1024.0 * (1 << 16)) / sampleRate;

function advanceOscillator(osc: Oscillator, frequency: number) {
    const toneStep = Math.floor(frequency * toneStepMult);
    osc.phase += toneStep;

    osc.value = osc.waveFn(osc, (osc.phase >> 16) & 1023, osc.phase >> 26) / 0x7fff
}


const SW_TRIANGLE = 1;
const SW_SAWTOOTH = 2;
const SW_SINE = 3;
const SW_TUNEDNOISE = 4;
const SW_NOISE = 5;
const SW_SQUARE_10 = 11;
const SW_SQUARE_50 = 15;
const SW_SQUARE_CYCLE_16 = 16;
const SW_SQUARE_CYCLE_32 = 17;
const SW_SQUARE_CYCLE_64 = 18;

 let x = 0xf01ba80;
function noiseTone(osc: Oscillator, position: number, cycle: number) {
    x ^= x << 13;
    x ^= x >> 17;
    x ^= x << 5;
    return (x & 0xffff) - 0x7fff;
}

function sineTone(osc: Oscillator, position: number, cycle: number) {
    let p = position;
    if (p >= 512) {
        p -= 512;
    }
    if (p > 256) {
        p = 512 - p;
    }
    // Approximate sin(x * pi / 2) with the odd polynomial y = cx^5 + bx^3 + ax
    // using the constraint y(1) = 1 => a = 1 - b - c
    //   => y = c x^5 + b x^3 + (1 - b - c) * x
    //
    // Do a least-squares fit of this to sin(x * pi / 2) in the range 0..1
    // inclusive, using 21 evenly spaced points. Resulting approximation:
    //
    // sin(x*pi/2) ~= 0.0721435357258*x**5 - 0.642443736562*x**3 + 1.57030020084*x
    // Scale the constants by 32767 to match the desired output range.
    const c = 0.0721435357258 * 32767;
    const b = -0.642443736562 * 32767;
    const a = 1.57030020084 * 32767;
    // Calculate using y = ((c * x^2 + b) * x^2 + a) * x
    //
    // The position p is x * 256, so after each multiply with p we need to
    // shift right by 8 bits to keep the decimal point in the same place.  (The
    // approximation has a negative error near x=1 which helps avoid overflow.)
    const p2 = p * p;
    const u = (c * p2 >> 16) + b;
    const v = (u * p2 >> 16) + a;
    const w = v * p >> 8;
    // The result is within 7/32767 or 0.02%, signal-to-error ratio about 38 dB.
    return position >= 512 ? -w : w;
}

function sawtoothTone(osc: Oscillator, position: number, cycle: number) {
    return (position << 6) - 0x7fff;
}

function triangleTone(osc: Oscillator, position: number, cycle: number) {
    return position < 512 ? (position << 7) - 0x7fff : ((1023 - position) << 7) - 0x7fff;
}

function squareWaveTone(osc: Oscillator, position: number, cycle: number) {
    return position < (102 * (osc.wave - SW_SQUARE_10 + 1)) ? -0x7fff : 0x7fff;
}

let tunedSeed = 0xf01ba80;
function tunedNoiseTone(osc: Oscillator, position: number, cycle: number) {
    // Generate a square wave filtered by a random bit sequence. Since the generator
    // is called multiple times per wave, use PlayingSound state data to ensure we
    // only generate a random bit once per wave, and then reuse it for future
    // calls for that wave.
    //
    // Use the low 6 bits of generatorState to store the last-used cycle, and
    // random_bit to store the last on/off state. (random_bit is arbitrary as
    // long as it isn't one of the low 6 bits.)
    const random_bit = 0x8000;
    const prev_cycle = osc.generatorState & 0x3f;
    let is_on;
    if (cycle == prev_cycle) {
        is_on = osc.generatorState & random_bit;
    }
    else {
        // see https://en.wikipedia.org/wiki/Xorshift
        tunedSeed ^= tunedSeed << 13;
        tunedSeed ^= tunedSeed >> 17;
        tunedSeed ^= tunedSeed << 5;
        is_on = (tunedSeed & random_bit);
        osc.generatorState = (cycle & 0x3f) | is_on;
    }
    if (!is_on)
        return 0;
    return position < 512 ? -0x7fff : 0x7fff;
}

// Bit patterns for use by the cyclic noise tone.
//
// The bit pattern is arbitrary, but should have equal numbers of 0 and 1 bits,
// and should avoid long identical-bit runs for the lower parts. The values below
// were chosen based on a random permutation of the hex nibbles 0..f and then
// hand-tweaked by swapping some nibbles. Generated by:
//
//   shuf -i 0-15 | perl -ne 's/(\d+)/printf("%x",$1)/e'
const cycle_bits = [0x2df0eb47, 0xc8165a93];
const cycle_mask = [0xf, 0x1f, 0x3f];

function cycleNoiseTone(osc: Oscillator, position: number, cycle: number) {
    // Generate a square wave filtered by a short-cycle pseudorandom bit sequence.
    // The bit sequence repeats every 16/32/64 waves.
    //
    // The "cycle" argument corresponds to the sequential number of the generated
    // wave. This is currently a 6-bit value. Since the pseudorandom bit sequences
    // evenly fit into this, there's no need to track generator state.
    const cycle_index = osc.wave - SW_SQUARE_CYCLE_16;
    // CLAMP(0, cycle_index, sizeof cycle_bits / sizeof cycle_bits[0])
    cycle &= cycle_mask[cycle_index];
    const is_on = (cycle_bits[cycle >> 5] & (1 << (cycle & 0x1f)));
    if (!is_on)
        return 0;
    return position < 512 ? -0x7fff : 0x7fff;
}

function silenceTone(osc: Oscillator, position: number, cycle: number) {
    return 0;
}

function getWaveFn(wave: number) {
    switch (wave) {
        case SW_TRIANGLE:
            return triangleTone;
        case SW_SAWTOOTH:
            return sawtoothTone;
        case SW_TUNEDNOISE:
            return tunedNoiseTone;
        case SW_NOISE:
            return noiseTone;
        case SW_SINE:
            return sineTone;
        default:
            if (SW_SQUARE_10 <= wave && wave <= SW_SQUARE_50)
                return squareWaveTone;
            if (SW_SQUARE_CYCLE_16 <= wave && wave <= SW_SQUARE_CYCLE_64)
                return cycleNoiseTone;
            else
                return silenceTone;
    }
}

function createOscillator(wave: number): Oscillator {
    const osc: Oscillator = {
        wave: wave,
        waveFn: getWaveFn(wave),
        generatorState: 0,
        phase: 0,
        value: 0
    };

    return osc;
}