<html>

<head>
    <meta charset="UTF-8">
    <title>Microsoft MakeCode Streamer</title>
    <style>
        /*
  Use https://uifabricicons.azurewebsites.net/
*/
/*
  Your use of the content in the files referenced here is subject to the terms of the license at https://aka.ms/fabric-assets-license
*/
@font-face {
  font-family: 'FabricMDL2Icons';
  src: url('data:application/octet-stream;base64,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') format('truetype');
}

.ms-Icon {
  -moz-osx-font-smoothing: grayscale;
  -webkit-font-smoothing: antialiased;
  display: inline-block;
  font-family: 'FabricMDL2Icons';
  font-style: normal;
  font-weight: normal;
  speak: none;
}

.ms-Icon--PenWorkspace:before { content: "\EDC6"; }
.ms-Icon--OpenPaneMirrored:before { content: "\EA5B"; }
.ms-Icon--Robot:before { content: "\E99A"; }
.ms-Icon--OfficeChat:before { content: "\F70F"; }
.ms-Icon--Settings:before { content: "\E713"; }
.ms-Icon--Contact:before { content: "\E77B"; }
.ms-Icon--EraseTool:before { content: "\E75C"; }
.ms-Icon--OpenPane:before { content: "\E8A0"; }

    </style>
    <style>
        /* 
            Style for the background. 
            
            Generate your custom css gradients at https://cssgradient.io/ 
        */
        body {
            font-family: monospace;
            overflow: hidden;
        }
        .container {
            padding-top: 56.25%;
            position: relative;
            width: 100%;            
        }

        footer {
            font-size: 70%;
            color: white;
            position: absolute;
            bottom: 0.5%;
            left: 1%;
            opacity: 90%;
            text-shadow: black 1px 1px;
        }

        footer>a {
            color: white;
            text-decoration: none;
        }

        /* 
            Style for the boxes.

            https://alligator.io/css/gradient-borders-pure-css/ 
        */
        .box {
            border: 0.5rem solid;
            border-radius: 0.5rem;

            transition: left 0.5s, right 0.5s, bottom 0.5s, top 0.5s, width 0.5s, height 0.5s, opacity 1s;
        }

        .hidden {
            display: none;
        }

        .rotate {
            transform: rotate(180deg);
            transform-origin: 50% 50%;
        }

        .ms-Icon {
            vertical-align: middle;
            margin-right: 0.2rem;
        }

        .item {
            cursor: pointer;
        }
        .error {
            border: solid 1px red;
            margin: 1rem 0rem 1rem 0rem;
            padding: 1rem;
            background: white;
        }
        #toolbox > button {
            height: 2rem;
            width: 2rem;
            border-radius: 1rem;
            background: black;
            color: white;
            padding: 0.47rem;
            margin: 0.25rem;
            cursor: pointer;
            opacity: 40%;
        }
        #toolbox > button:hover {
            opacity: 100%;
        }
        #banner {
            margin: 0.5vh;
        }
        canvas {
            display: none;
        }
        .paint canvas {
            display: block;
            position:absolute;
            width: 100%;
            height: 100%;
            left: 0;
            top: 0;
        }
        .paint {
            cursor:pointer !important;
        }

        /*
        Settings
        */
        #settings {
            position: absolute;
            left: 16%;
            top: 16%;
            width: 58%;
            height: 58%;
            background: #ccc;
            padding: 5% 5% 5% 5%;
            overflow-y: auto;
        }

        #settings .field {
            padding: 1% 0 1% 0;
        }

        #settings .field input {
            width: 100%;
            font-size: 90%;
        }

        #settings .field input[type="checkbox"] {
            width: unset;
        }

        #settings .field select {
            width: 100%;
            font-size: 90%;
        }

        #settings #settingsclose {
            position: absolute;
            right: 2%;
            top: 2%;
        }

        /*
            MakeCode editor box
        */
        #editor {
            position: absolute;
            width: 94%;
            height: 87%;
            top: 1%;
            transition-delay: 0.2s;
        }

        .multi #editor {
            width: 50%;
        }

        #editor2 {
            position: absolute;
            width: 50%;
            height: 87%;
            top: 1%;
            transition-delay: 0.3s;
        }

        /*
            Face camera            
        */
        #facecam, #hardwarecam {
            position: absolute;
            width: 30%;
            bottom: 1.5%;
            right: 1%;
        }
        #hardwarecam {
            width: 0;
            right: -1rem;
            opacity: 0;
        }
        body.hardware #hardwarecam {
            opacity: 100%;
        }

        /*
            Chat window
        */
        #chat {
            position: absolute;
            width: 0;
            height: 60%;
            top: 1%;
            right: 1%;
            display: none;
            transition-delay: 0.3s;
        }

        #social {
            position: absolute;
            width: 60%;
            height: 5%;
            left: 1%;
            bottom: 2%;
            background: #615fc7;
            transition-delay: 0.1s;
        }
        #toolbox {
            float:right;
        }

        span.social {
            font-size: 2vh;
            color: white;
            flex-grow: 1;
            margin: 1% 2% 1% 2%;
            text-align: center;
            cursor: pointer;
        }

        /** 
        * chat visibility
        */
        body.chat #chat {
            display: block;
            opacity: 90%;
        }

        /* rightscene: browser with facecam on right */
        body.rightscene #editor {
            left: 1%;
        }

        body.rightscene #facecam {
            right: 1%;
            width: 28%;
        }
        
        body.rightscene #chat {
            right: 1%;
            width: 28%;
            height: 54%;
        }

        body.rightscene.chat #editor {
            width: 67%;
            top: 1%;
            height: 87%;
        }

        body.rightscene.hardware #hardwarecam {
            right: 1%;
            width: 22%;
            bottom: 42%;
        }

        body.rightscene.multi #editor {
            width: 67%;
        }

        body.rightscene.multi #editor2 {
            width: 28%;
            left: 70%;
            height: 54%;
        }
        body.rightscene.multi.hardware #hardwarecam {
            right: 1%;
            width: 22%;
            bottom: 24%;
        }

        /* leftscene: browser with facecam on left left */
        body.leftscene #editor {
            left: 4%;
            height: 87%;
        }

        body.leftscene #facecam {
            right: 70%;
            width: 28%;
        }

        body.leftscene #hardwarecam {
            bottom: 9%;
            right: 1%;
        }

        body.leftscene #social {
            width: 55%;
            height: 5%;
            left: 43%;
            bottom: 1.5%;
        }
        body.leftscene.hardware #hardwarecam {
            width: 22%;
        }

        /* left+multi*/
        body.leftscene.multi #editor {
            left: 1%;
            width: 28%;
            height: 54%;
        }

        body.leftscene.multi #editor2 {
            width: 67%;
            left: 31%;
        }

        body.leftscene.multi #facecam {
            right: 70%;
            width: 28%;
        }
        body.leftscene.multi.hardware #hardwarecam {
            right: 76%;
            width: 22%;
            bottom: 24%;
        }

        /** leftscene + chat **/
        body.leftscene.chat #editor {
            left: 31%;
            width: 67%;
        }

        body.leftscene.chat #facecam {
            right: 70%;
            width: 28%;
        }

        body.leftscene.chat #chat {
            right: 70%;
            height: 54%;
            width: 28%;
        }

        /* chatscene: facecam and stream chat */
        body.chatscene #facecam {
            bottom: 19%;
            right: 38%;
            width: 52%;
        }

        body.chatscene #editor {
            left: -150rem;
        }
        body.chatscene #editor2 {
            right: -150rem;
        }

        body.chatscene #chat {
            top: 9%;
            right: 4%;
            width: 24%;
            height: 80%;
            opacity: 100%;
        }

        body.chatscene #social {
            left: 4%;
            bottom: 9%;
        }

        body.chatscene.hardware #facecam {
            bottom: 19%;
            right: 49%;
            width: 46%;
        }
        body.chatscene.hardware #hardwarecam {
            width: 46%;
            bottom: 19%;
            right: 1%;            
        }
    </style>
    <style id="editorstyle"></style>
</head>

<body class="rightscene">
    <div id="container" class="container">
    <iframe class="box" id="editor" allow="usb;camera"></iframe>
    <iframe class="box" id="editor2" allow="usb;camera"></iframe>
    <iframe class="box" id="chat" sandbox allow="allow-scripts"></iframe>
    <video class="box" autoplay="true" id="facecam"></video>
    <video class="box" autoplay="true" id="hardwarecam"></video>
    <canvas id="paint" class=""></canvas>
    <div class="box" id="social">
        <div id="toolbox">
        </div>
        <div id="banner"></div>
    </div>
    <div class="box hidden" id="settings">
        <button id="settingsclose">close</button>
        <h2>MakeCode Streamer settings</h2>
        <div class="field">
            <label for="editorselect">Choose your editor</label>
            <select id="editorselect"></select>
        </div>
        <div class="field">
            <input type="checkbox" id="multicheckbox"></input>
            <label for="multicheckbox">Multi editors</label>
        </div>
        <h2>Video</h2>
        <div class="field">
            <label for="facecamselect">Choose a Face Webcam</label>
            <select id="facecamselect"></select>
            <div class="error hidden" id="facecamerror">Connection error. Make sure the WebCam is not beging used by another application.</div>
        </div>
        <div class="field">
            <input type="checkbox" id="facerotatecameracheckbox"></input>
            <label for="facerotatecameracheckbox">Rotate camera 180</label>
        </div>
        <div class="field">
            <label for="hardwarecamselect">Choose a Hardware Webcam</label>
            <select id="hardwarecamselect"></select>
            <div class="error hidden" id="hardwarecamerror">Connection error. Make sure the WebCam is not beging used by another application.</div>
        </div>
        <div class="field">
            <input type="checkbox" id="hardwarerotatecameracheckbox"></input>
            <label for="hardwarerotatecameracheckbox">Rotate camera 180</label>
        </div>
        <h2>Social accounts</h2>
        <div class="field">
            <label for="twitterinput">Twitter (optional)</label>
            <input id="twitterinput" placeholder="Twitter handle (@account)" />
        </div>
        <div class="field">
            <label for="youtubeinput"">YouTube (optional)</label>
            <input id="youtubeinput" placeholder="YouTube account (/account)" />
        </div>
        <div class="field">
            <label for="mixerinput">Mixer (optional)</label>
            <input id="mixerinput" placeholder="Mixer.com account (/account)" />
        </div>
        <div class="field">
            <label for="twitchinput">Twitch (optional)</label>
            <input id="twitchinput" placeholder="Twitch.tv account (/account)" />
        </div>
    </div>
    <!-- @include tracking.html -->
    <footer>
        <a class="item" href="https://makecode.com/privacy" target="_blank" rel="noopener">Privacy &amp; Cookies</a>|
        <a class="item" href="https://makecode.com/termsofuse" target="_blank" rel="noopener">Terms Of Use</a>|
        <a class="item" href="https://makecode.com/trademarks" target="_blank" rel="noopener">Trademarks</a>|
        <span class="item">Â© 2020 Microsoft</span>
    </footer>
    <script>
        (async function () {
            const body = document.body;
            const container = document.getElementById("container");
            const editor = document.getElementById("editor");
            const editor2 = document.getElementById("editor2");
            const facecam = document.getElementById("facecam");
            const hardwarecam = document.getElementById("hardwarecam");
            const chat = document.getElementById("chat");
            const social = document.getElementById("social");
            const banner = document.getElementById("banner");
            const settings = document.getElementById("settings");
            const editorStyle = document.getElementById("editorstyle");
            const toolbox = document.getElementById("toolbox")
            const paint = document.getElementById('paint');
            const paintCtx = paint.getContext('2d');

            const frames = [editor, editor2];

            const scenes = ["leftscene", "rightscene", "chatscene"];
            const editorConfigs = await fetchJSON("/editors.json");
            const state = {
                sceneIndex: 1,
                left: false,
                chat: false,
                hardware: false
            }

            initMessages();
            loadPaint();
            await loadSettings()
            load();
            await loadFaceCam()
            await loadHardwareCam()
            tickEvent("streamer.load")

            function load() {
                loadEditor()
                loadChat()
                loadSocial()
                loadToolbox()
                render()
            }

            function saveConfig(config) {
                if (!config) throw "missing config"
                localStorage["streamer.config"] = JSON.stringify(config)
            }

            async function showSettings() {
                await loadSettings()
                settings.classList.remove("hidden")
            }

            function readConfig() {
                try {
                    const cfg = JSON.parse(localStorage["streamer.config"]);
                    return cfg;
                } catch (e) {
                    console.log(e)
                }

                const cfg = {
                    editor: "microbit",
                    multiEditor: false,
                    twitter: "",
                    youTube: "",
                    mixer: ""
                }
                saveConfig(cfg)
                return cfg;
            }

            async function fetchJSON(url) {
                const resp = await fetch(url)
                const json = await resp.json();
                return json;
            }

            function render() {
                const config = readConfig();
                body.className = `${scenes[state.sceneIndex]} ${state.hardware ? "hardware" : state.chat ? "chat" : ""} ${config.multiEditor ? "multi" : ""} ${state.paint ? "paint" : ""}`
                if (!config.faceCamId || state.faceCamError)
                    showSettings();
            }

            function loadToolbox() {
                const config = readConfig();
                toolbox.innerHTML = ""

                if (state.paint) {
                    addButton("EraseTool", "Exit paint mode", togglePaint)
                } else {
                    addButton("OpenPane", "move webcam left", () => setScene("left"))
                    addButton("OpenPaneMirrored", "move webcam right", () => setScene("right"))
                    addButton("Contact", "webcam large", () => setScene("chat"))
                    if (config.hardwareCamId)
                    addButton("Robot", "hardware webcam", toggleHardware)
                    if (config.mixer || config.twitch)
                        addButton("OfficeChat", "show/hide chat", toggleChat)
                    addButton("PenWorkspace", "Paint mode", togglePaint)
                    addButton("Settings", "Show settings", showSettings);
                }

                function addButton(icon, title, handler) {
                    const btn = document.createElement("button")
                    btn.title = title
                    btn.addEventListener("pointerdown", handler, false)
                    const i = document.createElement("i")
                    btn.append(i)
                    i.className = `ms-Icon ms-Icon--${icon}`
                    toolbox.append(btn)
                }

                function setScene(scene) {
                    tickEvent("streamer.scene", { scene: scene }, { interactiveConsent: true });
                    state.sceneIndex = scenes.indexOf(`${scene}scene`);
                    render();
                }
            }

            function togglePaint() {
                state.paint = !state.paint;
                clearPaint();
                updatePaintSize();
                loadToolbox();
                render();
            }

            function clearPaint() {
                paintCtx.clearRect(0,0,paint.width,paint.height);
            }

            function updatePaintSize() {
                const size = container.getBoundingClientRect();
                paint.width = size.width;
                paint.height = size.height;
                console.log(`paint size ${paint.width}x${paint.height}`)
            }

            function loadPaint() {
                const mouse = {x: 0, y: 0};
                
                paint.addEventListener('mousemove', function(e) {
                    mouse.x = e.pageX - this.offsetLeft;
                    mouse.y = e.pageY - this.offsetTop;
                }, false);
                
                paint.addEventListener('mousedown', function(e) {
                    paintCtx.lineWidth = Math.max(16, (paint.width / 100) | 0);
                    paintCtx.lineJoin = 'round';
                    paintCtx.lineCap = 'round';
                    paintCtx.strokeStyle = '#ffe135';
                    paintCtx.beginPath();
                    paintCtx.moveTo(mouse.x, mouse.y);
                
                    paint.addEventListener('mousemove', onPaint, false);
                }, false);
                
                paint.addEventListener('mouseup', function() {
                    paint.removeEventListener('mousemove', onPaint, false);
                }, false);
                
                function onPaint() {
                    console.log(`paint ${mouse.x} ${mouse.y}`)
                    paintCtx.lineTo(mouse.x, mouse.y);
                    paintCtx.stroke();
                }

                clearPaint();
            }

            function loadEditor() {
                const config = readConfig();
                // update first editor
                const editorConfig = editorConfigs[config.editor];
                if (!editorConfig) {
                    showSettings();
                    loadStyle();
                    return;
                }

                let url = `${editorConfig.url}?editorLayout=ide&nosandbox=1`;
                if (config.multiEditor)
                    url += `&nestededitorsim=1`;
                editor.src = url;
                if (config.multiEditor) {
                    if (!editor2.parentElement)
                        body.insertBefore(editor2, editor);
                    editor2.src = url;
                } else {
                    // remove from DOM
                    editor2.remove();
                }

                // update page style
                let css = "";
                const styles = editorConfig.styles;
                if (styles) {
                    css =
                        `body {
    background: ${styles.background};
}
.box {
    border-color: ${styles.menu};
}
#social {
    background: ${styles.primary};
}
`
                } else {
                    css =
                        `body {
    background: rgb(99, 93, 198);
    background: linear-gradient(45deg, rgba(99, 93, 198, 1) 0%, rgba(0, 212, 255, 1) 100%);
}
.box {
    border-image: conic-gradient(red, yellow, lime, aqua, blue, magenta, red) 1;
}
#social {
    background: #615fc7;
}
`
                }
                editorStyle.innerText = ""
                editorStyle.append(document.createTextNode(css));
            }

            function loadStyle() {
                const config = readConfig();
                const editorConfig = editorConfigs[config.editor];
                // update page style
                let css = "";
                const styles = editorConfig && editorConfig.styles;
                if (styles) {
                    css =
                        `body {
    background: ${styles.background};
}
.box {
    border-color: ${styles.menu};
}
#social {
    background: ${styles.primary};
}
`
                } else {
                    css =
                        `body {
    background: rgb(99, 93, 198);
    background: linear-gradient(45deg, rgba(99, 93, 198, 1) 0%, rgba(0, 212, 255, 1) 100%);
}
.box {
    border-image: conic-gradient(red, yellow, lime, aqua, blue, magenta, red) 1;
}
#social {
    background: #615fc7;
}
`
                }
                editorStyle.innerText = ""
                editorStyle.append(document.createTextNode(css));
            }

            function stopEvent(e) {
                e.preventDefault();
                e.stopPropagation();
            }

            function toggleChat(e) {
                tickEvent("streamer.togglechat", undefined, { interactiveConsent: true });
                stopEvent(e)
                const config = readConfig();
                state.chat = !state.chat && (config.mixer || config.twitch);
                render();
            }

            function toggleHardware(e) {
                tickEvent("streamer.togglehardware", undefined, { interactiveConsent: true });
                stopEvent(e)
                const config = readConfig();
                state.hardware = !state.hardware && config.hardwareCamId;
                render();
            }

            function loadSocial() {
                const config = readConfig();
                banner.innerHTML = ''
                if (config.twitter)
                    addSocial(`@${config.twitter}`)
                if (config.youTube)
                    addSocial(`youtube.com/${config.youTube}`);
                if (config.mixer)
                    addSocial(`mixer.com/${config.mixer}`);
                else if (config.twitch)
                    addSocial(`twitch.tv/${config.twitch}`);

                if (!config.mixer && !config.twitch)
                    state.chat = false;

                function addSocial(text) {
                    const a = document.createElement("span");
                    a.className = "social"
                    a.innerText = text
                    banner.append(a)
                }
            }

            function loadChat() {
                const config = readConfig();
                if (config.mixer) {
                    chat.src = `https://mixer.com/embed/chat/${config.mixer}?composer=false`;
                    if (!chat.parentElement)
                        body.insertBefore(chat, facecam)
                }
                else if (config.twitch) {
                    chat.src = `https://www.twitch.tv/embed/${config.twitch}/chat?parent=makecode.com`;
                    if (!chat.parentElement)
                        body.insertBefore(chat, facecam)
                }
                else // remove from dom
                    chat.remove();
            }

            async function listCameras() {
                let cams = await navigator.mediaDevices.enumerateDevices()
                cams = cams.filter(d => d.kind == "videoinput")
                return cams;
            }

            async function loadFaceCam() {
                // load previous webcam
                const config = readConfig();
                if (config.faceCamId) {
                    try {
                        state.faceCamError = false;
                        await startStream(facecam, config.faceCamId, config.faceCamRotate);
                        console.log(`face cam started`)
                        return; // success!
                    }
                    catch (e) {
                        stopStream(facecam);
                        state.faceCamError = true;
                        saveConfig(config)
                        console.log(`could not start face cam`, e)
                        render()
                    }
                } else {
                    state.faceCamError = true;
                    stopStream(facecam);
                }
            }

            async function loadHardwareCam() {
                // load previous webcam
                const config = readConfig();
                if (config.hardwareCamId) {
                    try {
                        state.hardwareCamError = false;
                        await startStream(hardwarecam, config.hardwareCamId, config.hardwareCamRotate);
                        console.log(`hardware cam started`)
                        return; // success!
                    }
                    catch (e) {
                        stopStream(hardwarecam)
                        state.hardwareCamError = true;
                        saveConfig(config)
                        console.log(`could not start web cam`, e)
                        render()
                    }
                } else {
                    state.hardwareCamError = false
                    stopStream(hardwarecam)
                }
            }


            function stopStream(el) {
                try {
                    if (el.srcObject) {
                        const tracks = el.srcObject.getVideoTracks();
                        if (tracks && tracks[0] && tracks[0].stop) tracks[0].stop();
                    }
                    el.srcObject = null;
                } catch (e) { }
            }

            function initMessages() {
                window.onmessage = function (msg) {
                    const data = msg.data;
                    const source = msg.source;
                    if (!!data.broadcast) {
                        data.outer = true;
                        frames
                            .filter(ifrm => ifrm.contentWindow !== source)
                            .forEach((ifrm) => ifrm.contentWindow.postMessage(data, "*"));
                    }
                };
            }

            async function startStream(el, deviceId, rotate) {
                stopStream(el)
                console.log(`trying webcam ${deviceId}`)
                const constraints = {
                    audio: false,
                    video: {
                        deviceId: deviceId,
                        aspectRatio: 4/3
                    }
                }
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                el.volume = 0; // don't use sound!
                el.srcObject = stream;
                el.onloadedmetadata = (e) => el.play();
                if (rotate)
                    el.classList.add("rotate")
                else
                    el.classList.remove("rotate");
            }

            async function loadSettings() {
                const config = readConfig();
                const cams = await listCameras()

                const settingsclose = document.getElementById("settingsclose")
                settingsclose.onclick = function (e) {
                    tickEvent("streamer.settingsclose", undefined, { interactiveConsent: true })
                    stopEvent(e)
                    settings.classList.add("hidden")
                }
                const editorselect = document.getElementById("editorselect");
                editorselect.innerHTML = "" // remove all web cams
                Object.keys(editorConfigs).forEach(editorid => {
                    const option = document.createElement("option")
                    option.value = editorid
                    option.text = editorConfigs[editorid].name;
                    editorselect.add(option)
                    if (config.editor == editorid)
                        option.selected = true;
                })
                editorselect.onchange = function () {
                    const selected = editorselect.options[editorselect.selectedIndex];
                    config.editor = selected.value;
                    saveConfig(config);
                    render()
                    loadEditor();
                }

                const multicheckbox = document.getElementById("multicheckbox")
                multicheckbox.checked = !!config.multiEditor
                multicheckbox.onchange = function () {
                    config.multiEditor = !!multicheckbox.checked
                    saveConfig(config)
                    render()
                    loadEditor()
                }

                const facecamselect = document.getElementById("facecamselect");
                facecamselect.innerHTML = "" // remove all web cams
                cams.forEach(cam => {
                    const option = document.createElement("option")
                    option.value = cam.deviceId
                    option.text = cam.label
                    facecamselect.add(option)
                    if (config.faceCamId == cam.deviceId)
                        option.selected = true;
                })
                facecamselect.onchange = function () {
                    const selected = facecamselect.options[facecamselect.selectedIndex];
                    config.faceCamId = selected.value;
                    if (config.hardwareCamId == config.faceCamId)
                        config.hardwareCamId = undefined; // priority to face cam
                    saveConfig(config)
                    loadFaceCam().then(() => loadSettings())
                }
                const facerotatecheckbox = document.getElementById("facerotatecameracheckbox")
                facerotatecheckbox.checked = !!config.faceCamRotate
                facerotatecheckbox.onchange = function () {
                    config.faceCamRotate = !!facerotatecheckbox.checked
                    saveConfig(config)
                    loadFaceCam().then(() => loadSettings())
                }
                const facecamerror = document.getElementById("facecamerror")
                if (config.faceCamId && state.faceCamError)
                    facecamerror.classList.remove("hidden")
                else
                    facecamerror.classList.add("hidden")

                const hardwarecamselect = document.getElementById("hardwarecamselect");
                hardwarecamselect.innerHTML = "" // remove all web cams
                const option = document.createElement("option")
                option.value = ""
                option.text = "Off"
                hardwarecamselect.add(option)
                cams.forEach(cam => {
                    const option = document.createElement("option")
                    option.value = cam.deviceId
                    option.text = cam.label
                    hardwarecamselect.add(option)
                    if (config.hardwareCamId == cam.deviceId)
                        option.selected = true;
                })
                hardwarecamselect.onchange = function () {
                    const selected = hardwarecamselect.options[hardwarecamselect.selectedIndex];
                    config.hardwareCamId = selected.value;
                    saveConfig(config)
                    state.hardware = !!config.hardwareCamId
                    loadToolbox()
                    render()
                    loadHardwareCam().then(() => loadSettings())
                }
                const hardwarerotatecheckbox = document.getElementById("hardwarerotatecameracheckbox")
                hardwarerotatecheckbox.checked = !!config.hardwareCamRotate
                hardwarerotatecheckbox.onchange = function () {
                    config.hardwareCamRotate = !!hardwarerotatecheckbox.checked
                    saveConfig(config)
                    loadHardwareCam().then(() => loadSettings())
                }
                const hardwarecamerror = document.getElementById("hardwarecamerror")
                if (config.hardwareCamId && state.hardwareCamError)
                    hardwarecamerror.classList.remove("hidden")
                else
                    hardwarecamerror.classList.add("hidden")

                const twitterinput = document.getElementById("twitterinput")
                twitterinput.value = config.twitter || ""
                twitterinput.onchange = function (e) {
                    config.twitter = (twitterinput.value || "").replace(/^https:\/\/twitter.com\//, '').replace(/^@/, '').trim()
                    twitterinput.value = config.twitter
                    saveConfig(config);
                    loadSocial()
                    render()
                }

                const youtubeinput = document.getElementById("youtubeinput")
                youtubeinput.value = config.youTube || ""
                youtubeinput.onchange = function (e) {
                    config.youTube = (youtubeinput.value || "").replace(/^https:\/\/youtube.com\//, '').replace(/^\//, '').trim()
                    youtubeinput.value = config.youTube
                    saveConfig(config);
                    loadSocial();
                    render()
                }

                const twitchinput = document.getElementById("twitchinput")
                twitchinput.value = config.twitch || ""
                twitchinput.onchange = function (e) {
                    config.twitch = (twitchinput.value || "").replace(/^https:\/\/twitch.tv\//, '').replace(/^\//, '').trim()
                    twitchinput.value = config.twitch
                    saveConfig(config);
                    loadSocial();
                    loadToolbox()
                    loadChat();
                    render()
                }

                const mixerinput = document.getElementById("mixerinput")
                mixerinput.value = config.mixer || ""
                mixerinput.onchange = function (e) {
                    config.mixer = (mixerinput.value || "").replace(/^https:\/\/mixer.com\//, '').replace(/^\//, '').trim()
                    mixerinput.value = config.mixer
                    saveConfig(config);
                    loadSocial();
                    loadToolbox()
                    loadChat();
                    render()
                }
            }

            function tickEvent(id, data, opts) {
                if (typeof pxt === "undefined" || !pxt.aiTrackException || !pxt.aiTrackEvent) return;
                if (opts && opts.interactiveConsent && typeof mscc !== "undefined" && !mscc.hasConsent()) {
                    mscc.setConsent();
                }
                const config = readConfig();
                const props = {
                    editor: config.editor,
                };
                const measures = {
                    multiEditor: config.multiEditor ? 1 : 0,
                    twitter: config.twitter ? 1 : 0,
                    mixer: config.mixer ? 1 : 0,
                    twitch: config.twitch ? 1 : 0
                };
                if (data)
                    Object.keys(data).forEach(k => {
                        if (typeof data[k] == "string") props[k] = data[k];
                        else if (typeof data[k] == "number") measures[k] = data[k];
                        else props[k] = JSON.stringify(data[k] || '');
                    });
                pxt.aiTrackEvent(id, props, measures);
            }
        })()
    </script>
    </div>
</body>

</html>