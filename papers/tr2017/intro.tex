\section{Introduction}
\label{sec:intro}

Over the last decade, microcontrollers, the workhorses of embedded systems, have become
central to efforts in making~\cite{dougherty2012maker} and education. For example, the Arduino project
(\url{www.arduino.cc})~\cite{buildingArduino2014},
started in 2003, created the Uno board using an 8-bit Atmel
AVR microcontroller. The Uno makes its microcontroller's I/O pins available via headers;
external hardware modules (shields) may be connected to these headers to extend
the Uno's capability. The Arduino ecosystem has grown tremendously in the past 15 years,
with the support of companies such as Adafruit Industries (\url{www.adafruit.com}) and
Sparkfun Electronics (\url{www.sparkfun.com}), who resell Arduino and make their
own Arduino-compatible boards. 

The Arduino platform has the following characteristics, common to many programming
environments for microcontrollers~\cite{XYZ}:
\begin{itemize}
\item it uses C/C++ as the starting programming language;
\item it loads code using 1980's era bootloader technology;
\item it encourages polling of sensors;
\item it lacks many interactive features of modern IDEs;
\end{itemize}
These characteristics make such systems non-trivial for beginners to work with, 
require the installation of OS-specific drivers/applications/toolchains,
and leads to poor programming practices.

The Java language (among others) held out the promise of a better way forward for 
programming microcontrollers, but XYZ.  
\flameon{we need more description of why current ways of programming microcontrollers 
make for a high barrier to entry; also need to take on Java head on here, as well as
RTOS and MicroPython.}

In contrast to the situation for programming microcontrollers, 
on the web we find many excellent environments for introductory programming.
Visual block editors such as Scratch (\url{https://scratch.mit.edu/})~\cite{ScratchCACM2009,BlocksBeyondCACM2017}
and Blockly (\url{https://developers.google.com/blockly/})~\cite{Blocky2015}
allow the creation of programs without the possibility of syntax errors.
The programming models associated with Scratch and Blockly generally are
event based, freeing the programmer from the need to poll.
HTML, CSS and JavaScript allow a complete programming experience to be delivered as an interactive
web app, including editing with intellisense, code execution and debugging~\cite{Monaco}. 

With a surge in the demand of microcontroller-based devices for education~\cite{XYZ}, 
there is a need to simplify the programming of such devices so that they suitable 
for novice users in restricted environments.
Therefore, we have created a new programming platform that bridges the worlds of 
the microcontroller and the web app. 

The major goals of the platform are to:
% TypeScript / Blocks + MakeCode
(1) make it simple to program microcontrollers in a higher-level language,
using nothing more than a web app;
% TypeScript and Blocks prevent users from making boo boos.
(2) provide a safe environment for users to develop programs for microcontrollers;
% simulator, auto completion...
(3) create a feature rich and extensible development environment that decreases time taken to program a microcontroller (time to awesome);
% UF2 is awesome
(4) allow a users' compiled program to be easily installed on a microcontroller;


The platform consists of a stack of four novel technologies, the subject of
this paper:
\begin{itemize}
\item \emph{\MC (\href{https://makecode.com}{makecode.com})}, a web app that supports both visual block programming and text programming,
via \emph{Static TypeScript}, with conversion between the two program representations (Section~\ref{sec:makecode});

\item \emph{Static TypeScript}, a statically-typed subset of TypeScript (\url{www.typescriptlang.org}),
a gradually-typed superset of JavaScript, for fast execution on low-memory devices, with
a simple model for linking against pre-compiled C++ (Section~\ref{sec:sts});

\item \emph{\CO (the Component-oriented Device Abstraction Layer)}, an event driven, multi-threaded, C++ runtime environment that bridges the semantic gap between higher-level languages and the hardware,
modelling each hardware component as a software component (Section~\ref{sec:codal});

\item \emph{USB Flashing Format} (UF2), a new file format designed for flashing microcontrollers 
over the Mass Storage Class protocol (USB pen drives); the format greatly speeds the installation of user
programs and is robust to differences in operating systems (Section~\ref{sec:uf2}).
\end{itemize}
The \MC web app is the entry point of the platform, and has in-browser execution via a device simulator, as well as compilation to machine code and linking against a
pre-compiled C++ runtime (\emph{\CON}). No C/C++ compiler is invoked to compile user code and the result of compilation is a binary file that is ``downloaded'' from the web app to the user's
computer and then flashed to the microcontroller (exposed as a USB pen drive) 
via a simple file copy operation,  with the aid of the \emph{UF2} file format and supporting firmware. 


These four advances enable beginners to get started programming microcontrollers from 
any modern web browser, and enable hardware vendors to innovate and safely add new 
components to the mix using Static TypeScript, leveraging its
foreign function interface to C++.
Once the web app has been loaded, all the above functionality works offline 
(i.e., if the host machine loses its connection
to the internet). 

\begin{table}[]
\centering
\begin{tabular}{|l|r|r|r|r|r|}
\hline
            &          &            & \bf{Word} &          &             \\
\bf{Device} & \bf{RAM} & \bf{Flash} & \bf{Size} & \bf{CPU} & \bf{Chip}   \\ \hline
Uno         & 2 kB     & 32 kB      & 8         & AVR      & ATmega328P  \\ \hline
micro:bit   & 16 kB    & 256 kB     & 32        & M0       & nRF52       \\ \hline
CPX         & 32 kB    & 256 kB     & 32        & M0       & SAMD21      \\ \hline
\end{tabular}
\caption{\label{table:devices}A subset of devices supported by the platform. 
CPX is Adafruit's Circuit Playground Express. M0 denotes Cortex-M0.}
\end{table}
      
Table~\ref{table:devices} lists three of the devices supported by our platform, ranging
from the highly resource-contrained Arduino Uno to the slightly less constrained space of
the micro:bit and Adafruit Circuit Playground Express (CPX).


\subsection{Running Example}

Figure~\ref{fig:example} shows a program in the Static
TypeScript subset that implements a simple ``stopwatch'' timer
for the micro:bit.
The program has three top-level statements:
the first initializes the global variable \emph{start} (line 1); the
second registers an event handler (a lambda function) to execute
each time button A of the micro:bit is pressed (line 3); the
third registers a lambda function to run forever on a fiber (line 18),
to animate the micro:bit's 5x5 LED screen whenever the timer is active. 

Note that this program is a JavaScript program, as there are no 
types mentioned explicitly. However, all the functions called in
this program are part of the runtime and are explicitly
typed.  As a result, the static type of every variable and expression
can be inferred by TypeScript's type inference.

The program also shows off the use of the non-preemptive concurrency
model supported by both \MC (for JavaScript) and \CO (for C++). 
The fiber running the forever statement executes the lambda inside a ``while (true)'' 
loop that yields (via a call to \emph{basic.pause}) after each call to the lambda.
This gives the button-press event handler a chance to execute
upon user input (in a separate fiber). Although the global variable \emph{start} is 
shared by the two fibers, there is no data race due to the non-preemptive 
scheduling model. 

\flameon{TODO: event queueing/execution model???}



\begin{figure}
\begin{lstlisting}
let start = 0

input.onButtonPressed(Button.A, () => {
  if (start == 0) {
    start = input.runningTime()
  } else {
    let d = input.runningTime() - start
    start = 0 
    basic.clearScreen()
    basic.pause(1000)
    basic.showString(d/1000 + "." + d%1000)
  }
})

basic.forever(() => {
  if (start) {
    led.toggle(Math.random(5), Math.random(5))
  }
})
\end{lstlisting}
\caption{\label{fig:example}Running example.}
\end{figure}

\subsection{Evaluation}

%we encourage the reader to choose a target
%from \url{www.makecode.com} and experiment with programming it, to appreciate the
%qualitative aspects of the platform, namely its simplicity and ease of use.
In this paper, we evaluate quantitative aspects of the platform
with respect to the devices from Table~\ref{table:devices}. In particular, we
consider:
\begin{itemize}
\item the time to compile Static TypeScript user code (to machine code) with respect
      to the GCC C/C++ toolchain, as well as the size of the resulting executable;
\item the time to load code onto a microcontroller using UF2, compared to standard bootloaders
      such as Arduino and ARM's DAPlink;
\item the performance of a set of small benchmarks, written in both Static TypeScript and C++,
      compiled with the \MC and GCC toolchains;
\item \emph{energy consumption: \CO vs. Arduino}
\item \emph{native code vs. bytecode} we
      evaluate memory consumption and code performance for native code generation
      vs. bytecode generation and interpretation on the Uno.
\end{itemize}

\flameon{TODO: we should present some of high-level experimental results here.}

All of the platform's components are open source on GitHub.
  
Sections~\ref{sec:makecode} to~\ref{sec:uf2} presents the four major components of the platform, top-down,
as referenced before. Section~\ref{sec:evaluate} evaluates the performance of the platform,
Section~\ref{sec:related} discusses related work, and Section~\ref{sec:conclude}
concludes.
