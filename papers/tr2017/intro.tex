\section{Introduction}
\label{sec:intro}

Over the last decade, microcontrollers, the workhorses of embedded systems, have found
new uses in making~\cite{dougherty2012maker} and education. For example, the Arduino project
(\url{www.arduino.cc})~\cite{buildingArduino2014},
started in 2003, created the Uno board using an 8-bit Atmel
AVR microcontroller. 
The Arduino ecosystem has grown over the past 15 years,
with the support of companies such as Adafruit Industries (\url{www.adafruit.com}), 
who resell Arduino and make their own Arduino-compatible boards, as well as providing
how-to guides for beginners to start working with microcontrollers.

Furthermore, demand for microcontrollers is brisk due to their use in the monitoring and controlling
of a wide variety of systems, ranging from wearables, to home automation, to industrial 
automation and smart grids. s\emph{compare CPU to microcontroller - what distinguishes MCU from CPU - 
compute to memory ratio - MCU has simple pipeline, very predictable performance}
Application programming of microcontrollers generaly requires a professional
development environment. 

% https://globenewswire.com/news-release/2015/12/24/798090/0/en/Microcontroller-Market-Worth-26-98Bn-By-2020-Grand-View-Research-Inc.html
% "The global microcontroller market size was valued at USD 24.61 billion in 2015. The substantial growth in automobile, 
% consumer electronics, and the healthcare sector is expected to attribute to the industry growth.
% The global microcontroller market is expected to reach USD 26.98 billion by 2020,"

% https://www.morganstanley.com/ideas/microcontrollers-semiconductors-internet-of-things
% "Embedded in a product, these tiny chips can efficiently sense, process, 
% and control operations at low cost.  Over the years, chipmakers have been making them 
% smaller, more energy efficient, less expensive, and geared for a mobile and wireless world."

% The Arduino platform has the following characteristics, common to many programming
% environments for microcontrollers~\cite{XYZ}:
% \begin{itemize}
% \item it uses C/C++ as the starting programming language;
% \item it loads code using 1980's era bootloader technology;
% \item it encourages polling of sensors;
% \item it lacks many interactive features of modern IDEs;
% \end{itemize}
% These characteristics make such systems non-trivial for beginners to work with,
% require the installation of OS-specific drivers/applications/toolchains,
% and leads to poor programming practices.

%The Java language (among others) held out the promise of a better way forward for
%programming microcontrollers, but XYZ.
%\flameon{we need more description of why current ways of programming microcontrollers
%make for a high barrier to entry; also need to take on Java head on here, as well as
%RTOS and MicroPython.}

In comparison, on the web we find many environments for introductory programming.
Visual block editors such as Scratch (\url{https://scratch.mit.edu/})~\cite{ScratchCACM2009,BlocksBeyondCACM2017}
and Blockly (\url{https://developers.google.com/blockly/})~\cite{Blocky2015}
allow the creation of programs without the possibility of syntax errors.
The programming models associated with Scratch and Blockly generally are
event based, freeing the programmer from the need to poll.

% HTML, CSS and JavaScript allow a complete programming experience to be delivered as an interactive
% web app, including editing with code completion, code execution and debugging~\cite{Monaco}.

With a surge in the demand for microcontroller-based devices across a wide
spectrum of applications, 
there is a need to simplify the programming of such devices.
Therefore, we have created a new programming platform that bridges the worlds of
the web app and the microcontroller. 

The major goals of the platform are to:
% TypeScript / Blocks + MakeCode
(1) make it simple to program microcontrollers in a higher-level language,
using nothing more than a web app;
% TypeScript and Blocks prevent users from making boo boos.
(2) provide a safe environment for users to develop programs for microcontrollers;
% simulator, auto completion...
(3) create a feature rich and extensible development environment 
that decreases time taken to program a microcontroller;
% UF2 is awesome
(4) allow a users' compiled program to be easily installed on a microcontroller;


The platform consists of a stack of four novel technologies, the subject of
this paper:
\begin{itemize}
\item \emph{\MCN}, a web app that supports both visual block programming and text programming,
via \emph{Static TypeScript}, with conversion between the two program representations (Section~\ref{sec:makecode});

\item \emph{Static TypeScript}, a statically-typed subset of TypeScript (\url{www.typescriptlang.org}),
a gradually-typed superset of JavaScript, for fast execution on low-memory devices, with
a simple model for linking against pre-compiled C++ (Section~\ref{sec:sts});

\item \emph{\CO}, a component-based, event-driven, multi-threaded, C++ runtime environment that bridges the semantic gap between higher-level languages and the hardware,
modelling each hardware component as a software component (Section~\ref{sec:codal});

\item \emph{\UFN}, a new file format designed for flashing microcontrollers
over the Mass Storage Class protocol (USB pen drives); the format greatly speeds the installation of user
programs and is robust to differences in operating systems (Section~\ref{sec:uf2}).
\end{itemize}
The \MC web app is the entry point of the platform, and has in-browser execution via a device simulator, as well as compilation to machine code and linking against a
pre-compiled C++ runtime (\emph{\CON}). No C/C++ compiler is invoked to compile user code and the result of compilation is a binary file that is ``downloaded'' from the web app to the user's
computer and then flashed to the microcontroller (exposed as a USB pen drive)
via a simple file copy operation,  with the aid of the \emph{UF2} file format and supporting firmware.

These four advances enable beginners to get started programming microcontrollers from
any modern web browser, and enable hardware vendors to innovate and safely add new
components to the mix using Static TypeScript, leveraging its
foreign function interface to C++.
Once the web app has been loaded, all the above functionality works offline
(i.e., if the host machine loses its connection
to the internet). All of the platform's components are open source on GitHub.

\begin{table}[]
\centering
\begin{tabular}{|l|r|r|r|r|r|}
\hline
            &          &            & \bf{Word} &          &             \\
\bf{Device} & \bf{RAM} & \bf{Flash} & \bf{Size} & \bf{CPU} & \bf{Chip}   \\ \hline
Uno         & 2 kB     & 32 kB      & 8         & AVR      & 328P  \\ \hline
micro:bit   & 16 Kb    & 128 KB     & 32        & M0       & nRF51       \\ \hline
CPX         & 32 kB    & 256 kB     & 32        & M0       & SAMD21      \\ \hline
\end{tabular}
\caption{\label{table:devices}A subset of devices supported by the platform.
CPX is Adafruit's Circuit Playground Express. M0 denotes Cortex-M0 and 328P denotes
the Atmega328P.}
\end{table}

Table~\ref{table:devices} lists a number of the devices/microcontrollers supported by our platform, 
ranging from the highly resource-contrained Arduino Uno to the slightly less constrained space of
the micro:bit, and Adafruit Circuit Playground Express (CPX).

\subsection{Running Example: firefly simulation.}

Figure~\ref{fig:example} shows a program in the Static
TypeScript subset that implements a simple ``firefly'' example
for the Adafruit Circuit Playground Express (CPX).
The program has three top-level statements:
the first initializes the global variable \emph{clock} (line 1); the
second registers an event handler (a lambda function) to execute
each time the CPX's light detector senses a bright light (line 3); the
third registers a lambda function to run forever on a fiber (line 18),
to keep track of time and pulse all of the CPX's to white whenever the
clock reaches 8.  This program demonstrates the natural phenomenon
of fireflies synchronizing their light pulses (the program should be
run on several CPX's close to each other in a dark room).

Note that this program is a JavaScript program, as there are no
types mentioned explicitly. However, all the functions called in
this program are part of the runtime and are explicitly
typed.  As a result, the static type of every variable and expression
can be inferred by TypeScript's type inference.

The program also shows off the use of the non-preemptive concurrency
model supported by both \MC (for JavaScript) and \CO (for C++).
The forever procedure executes the lambda inside a ``while (true)''
loop that yields (via a call to \emph{basic.pause}) after each call to the lambda.
This gives the light-detection event handler a chance to execute
upon user input (in a separate fiber). Although the global variable \emph{clock} is
shared by the two fibers, there is no data race due to the non-preemptive
scheduling model.

\begin{figure}
\begin{lstlisting}
  let clock = 0

  input.onLightConditionChanged(
    LightCondition.Bright, () => {
      if (clock < 8) {
          clock += 1    // catchup to neighbor
      }
  })

  loops.forever(() => {
    if (clock >= 8) {
        // notify neighbors
        light.setAll(Colors.White)  
        loops.pause(200)
        light.clear()
        clock = 0         // reset the clock
    } else {
        loops.pause(100)
        clock += 1         
    }
})
\end{lstlisting}
\caption{\label{fig:example}Running example: firefly simulation.}
\end{figure}


\subsection{Evaluation}

%we encourage the reader to choose a target
%from \dburl{www.makecode.com} and experiment with programming it, to appreciate the
%qualitative aspects of the platform, namely its simplicity and ease of use.
In this paper, we evaluate quantitative aspects of the platform
with respect to the devices from Table~\ref{table:devices}. In particular, we
consider:
\begin{itemize}
\item the time to compile Static TypeScript to machine code or bytecode,
       as well as the size of the resulting executable, including the C++ runtime;
\item the performance of a set of small benchmarks, written in both Static TypeScript and C++,
      compiled with the \MC and GCC toolchains;
\item the time to load code onto a microcontroller using UF2, compared to standard bootloaders
      such as Arduino and ARM's DAPlink;
%\item \emph{native code vs. bytecode} we
%      evaluate memory consumption and code performance for native code generation
%      vs. bytecode generation and interpretation on the Uno.
\end{itemize}
The high-level results are: compilation speed in the browser is on the order
of several hundred milliseconds for small programs (the norm), so not noticeable 
by the end-user; execution slowdown for Static TypeScript code relative to C++
code is 2x-3x, which compares very well to systems such as MicroPython and
Circuit Python, which incur 100X slowdown. \flameon{Flashing speed}

%\flameon{TODO: we should present some of high-level experimental results here.}

Sections~\ref{sec:makecode} to~\ref{sec:uf2} presents the four major components of the platform, top-down,
as referenced before. Section~\ref{sec:evaluate} evaluates the performance of the platform,
Section~\ref{sec:related} discusses related work, and Section~\ref{sec:conclude}
concludes.
