\section{Introduction}
\label{sec:intro}

Over the last decade, microcontrollers, the workhorses of embedded systems, have become
central to efforts in making~\cite{dougherty2012maker} and education. For example, the Arduino project
(\url{www.arduino.cc})~\cite{buildingArduino2014},
started in 2003, created the Uno board using an 8-bit Atmel
AVR microcontroller. The Uno makes its microcontroller's I/O pins available via headers;
external hardware modules (shields) may be connected to these headers to extend
the Uno's capability. The Arduino ecosystem has grown tremendously in the past 15 years,
with the support of companies such as Adafruit Industries (\url{www.adafruit.com}) and
Sparkfun Electronics (\url{www.sparkfun.com}). What is surprising about the Arduino platform is that
it:
\begin{itemize}
\item encourages the programmer to poll sensors, leading to monolithic programs;
\item uses C/C++ as the programming language, increasing the barrier to entry and creating an unsafe environment for users;
\item lacks any code ``intellisense'' or common interactive features of modern IDEs, slowing development;
\item loads code onto the microcontroller using 1980's era bootloader technology, requiring the installation of local applications.
\end{itemize}
On the other hand, on the web we find many excellent environments for introductory programming.
Visual block editors such as Scratch (\url{https://scratch.mit.edu/})~\cite{ScratchCACM2009,BlocksBeyondCACM2017}
and Blockly (\url{https://developers.google.com/blockly/})~\cite{Blocky2015}
allow the creation of programs without the possibility of syntax errors.
The programming models associated with Scratch and Blockly generally are
event based, freeing the programmer from the need to poll.
HTML, CSS and JavaScript allow a complete programming experience to be delivered as an interactive
web app, including editing with intellisense, code execution and debugging~\cite{Monaco}. With a surge
in the demand of microcontroller-based devices for education, there is a need to simplify the programming of such devices so that they suitable for novice users in restricted environments.

Therefore, we have created a new programming platform that bridges the worlds of the microcontroller
and the web app. The major goals of the platform are to:
% TypeScript / Blocks + MakeCode
(1) make it simple to program microcontrollers in a higher-level language, using nothing more than a web app;
% TypeScript and Blocks prevent users from making boo boos.
(3) provide a safe environment for users to develop programs for microcontrollers;
% simulator, auto completion...
(2) create a feature rich and extensible development environment that decreases time taken to program a microcontroller (time to awesome);
% UF2 is awesome
(4) allow a users' compiled program to be easily installed on a microcontroller;

\begin{figure*}[t]
  \includegraphics[width=5.5in]{reposFig.pdf}
  \caption{\label{fig:repos}Relationships between platform components/repos. Yellow boxes represent the \MC (PXT) components; blue
  boxes represent the \CO components; green boxes represent external components.}
\end{figure*}

The platform consists of a stack of four novel technologies, the subject of
this paper:
\begin{itemize}
\item \emph{\MC (\href{https://makecode.com}{makecode.com})}, a web app that supports both visual block programming and text programming,
via \emph{Static TypeScript}, with conversion between the two program representations

\item \emph{Static TypeScript}, a statically-typed subset of TypeScript (\url{www.typescriptlang.org}),
a gradually-typed superset of JavaScript, for fast execution on low-memory devices, with
a simple model for linking against pre-compiled C++;

\item \emph{\CO (the Component-oriented Device Abstraction Layer)}, an event driven, multi-threaded, C++ runtime environment that bridges the semantic gap between higher-level languages and the hardware,
modelling each hardware component as a software component.

\item \emph{USB Flashing Format} (UF2), a new file format designed for flashing microcontrollers over the Mass Storage
Class protocol; the format greatly speeds the installation of user
programs and is robust to differences in operating systems.
\end{itemize}
The \MC web app is the entry point of the platform, and has in-browser execution via a device simulator, as well as compilation to machine code and linking against a
pre-compiled C++ runtime (\emph{\CON}). No C/C++ compiler is invoked to compile user code and the result of compilation is a binary file that is ``downloaded'' from the web app to the user's
computer and then flashed to the microcontroller, with the aid of the \emph{UF2} file format.

These four advances enable beginners to get started programming microcontrollers from any modern web browser, and enable
hardware vendors to innovate and safely add new components to the mix using Static TypeScript, leveraging its
foreign function interface to C++.
Once the web app has been loaded, all the above functionality works offline (i.e., if the host machine loses its connection
to the internet).

\begin{table}[]
\centering
\begin{tabular}{|l|l|l|l|l|}
\hline
Device             & RAM (kB) & Flash (kB) & Word Size        \\ \hline
Arduino Uno        & 2        & 32         & 8               \\ \hline
BBC micro:bit      & 16       & 256        & 32              \\ \hline
Circuit Playground & 32       & 256        & 32              \\ \hline
\end{tabular}
\caption{\label{table:devices}A subset of devices supported by the platform.}
\end{table}
Whilst this paper focuses on three devices listed in Table~\ref{table:devices}, we encourage the reader to choose a target
from \url{www.makecode.com} and experiment with programming it, to appreciate the
qualitative aspects of the platform, namely its simplicity and ease of use.
This paper evaluates quantitative aspects of the platform:
compilation speed, code size, and runtime performance.  In particular, we
consider:
\begin{itemize}
\item the time to compile Static TypeScript user code (to machine code) with respect
      to the GCC C/C++ toolchain, as well as the size of the resulting executable;
\item the time to load code onto a microcontroller using UF2, compared to standard bootloaders
      such as Arduino and ARM's DAPlink;
\item the performance of a set of small benchmarks, written in both Static TypeScript and C++,
      compiled with the \MC and GCC toolchains;
\item \emph{energy consumption: \CO vs. Arduino}
\item \emph{native code vs. bytecode} we
      evaluate memory consumption and code performance for native code generation
      vs. bytecode generation and interpretation on the Uno.
\end{itemize}


\begin{figure*}[t]
      \includegraphics[width=5in]{screenSnapFig.pdf}
  \caption{\label{fig:screenSnap}Screen snapshot of the \MC web app.}
\end{figure*}

All of the platform's components are open source on GitHub.
Figure~\ref{fig:repos} lists the major GitHub repos of the platform
and the dependences between them. Green boxes represent repos external to the platform
(note: not all repos are represented in the figure).

The \MC framework
is at \emph{\href{https://github.com/microsoft/pxt}{pxt}} (PXT is the previous codename of \MCN).
A \emph{pxt-target} extends the framework to create an environment for a specific board. Targets
for the three previously mentioned boards are at:
~\emph{\href{https://github.com/microsoft/pxt-microbit}{pxt-microbit}},
~\emph{\href{https://github.com/microsoft/pxt-adafruit}{pxt-adafruit}}, and
~\emph{\href{https://github.com/microsoft/pxt-arduino-uno}{pxt-arduino-uno}}.
The latter two targets make use of a common set of libraries,
\emph{\href{https://github.com/microsoft/pxt-common-packages}{pxt-common-packages}},
which build upon \CON's microcontroller independent core abstractions at
~\emph{\href{https://github.com/lancaster-university/\CO-core}{\COLN-core}}.

Platform- and microcontroller-dependent specialization and optimizations for
the SAMD21 and Atmega328 microcontrollers can be found at
~\emph{\href{https://github.com/lancaster-university/codal-samd21}{\COLN-samd21}},
and
~\emph{\href{https://github.com/lancaster-university/codal-atmega328p}{\COLN-atmega328p}}.
Not shown in the figure, the SAMD21 repo uses another repo for
MBED-specific optimizations for the Cortex-M0 processor: \emph{\href{https://github.com/lancaster-university/codal-mbed}{\COLN-mbed}}.

The repo \emph{\href{https://github.com/lancaster-university/codal}{\COLN}} provides the
tools for compiling a \CO target.  As can be seen in Figure~\ref{fig:repos},
\CO abstracts over platform and microcontroller specific
implementations, while PXT abstracts over programming editors and languages.
The UF2 specification is at~\emph{\href{https://github.com/microsoft/uf2}{uf2}},
with implementations at~\emph{\href{https://github.com/microsoft/uf2-samd21}{uf2-samd21}}
and~\emph{\href{https://github.com/mmoskal/uf2-uno}{uf2-uno}}. These repos are not
shown in the Figure.
The pxt-microbit target uses a predecessor of the \CO called the DAL (at
~\emph{\href{https://github.com/lancaster-university/microbit-dal}{microbit-dal}}).

The rest of this paper presents the four major components of the platform,
top-down: Section~\ref{sec:makecode} presents the design
and implementation of the \MC framework, while
Sections~\ref{sec:sts},~\ref{sec:codal} and~\ref{sec:uf2} describe Static TypeScript,
the \CO C++ runtime, and the UF2 flashing format, respectively.
Section~\ref{sec:evaluate} evaluates the performance of the platform,
Section~\ref{sec:related} discusses related work, and Section~\ref{sec:conclude}
concludes.
