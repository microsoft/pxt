
\begin{figure*}[t]
    \includegraphics[width=6in]{CPXfig.pdf}
\caption{\label{fig:screenSnap}Screen snapshot of the \MC web app, showing the Blockly
view of the JavaScript from Figure~\ref{fig:example}.}
\end{figure*}


\section{\MCN: Design and Implementation}
\label{sec:makecode}
% @TOM REVIEW:
The key technical contribution of \MC is to provide users with a safe environment to write programs for MCUs, enabling a simple progression from block-based
programming, to text-based programming in Static TypeScript (STS), 
while leveraging C++ on the backend for efficient use of MCU resources.

Figure~\ref{fig:screenSnap} shows a screen snapshot of the \MC web app for the CPX,
which has five sections:
(A) the menu bar allows switching between the two editors;
(B) the simulator shows the CPX board and provides feedback on user code executed in the browser;
(C) the toolbar provides access to device-specific APIs and programming elements;
(D) the programming canvas (showing here the blocks corresponding to the JavaScript from Figure~\ref{fig:example});
(E) the download button invokes the compiler to produce a binary executable.

The web app encapsulates all the components needed to deliver a programming experience
for MCUs, free of the need for a C++ compiler for the compilation of user code.
The web app is written in TypeScript and incorporates the TypeScript compiler and
language service as well.
The app is built from a \MC ``target''
which parameterizes the \MC framework for a particular device.
The remaining subsections describe the essential components of the web app 
from Figure~\ref{fig:makecode}.

\subsection{Device runtime and Shim Generation}

A \MC target is defined, in part, by its device runtime, which can be a combination of C++
and STS code, as shown in the lower-left of Figure~\ref{fig:makecode}.
All the target's C++ files are precompiled (by a C++ compiler in the cloud)
into a binary, which is stored in the cloud in a single blob, as well asin the HTML5 application cache. Additional runtime
components may be authored in STS, which allows the device runtime to be extended without the
use of C++, and permits components of the device runtime to be shared by both the device
and simulator runtimes. The ability to author the device runtime in both STS and C++ is
a unique aspect of \MCN's design.

Whether runtime components are authored in C++ or STS, all runtime APIs are exposed as fully-typed
TypeScript definitions. A fully-typed runtime improves the end-user experience
by making it easier to discover APIs; it also enables the type inference provided by the TypeScript
compiler to infer types for (unannotated) user programs, as in Figure~\ref{fig:example}.

\MC supports a simple foreign function interface from STS to C++ based on namespaces,
enumerations, functions, and basic type mappings. \MC uses top-level namespaces to organize sets of related functions.  Preceding a C++ namespace, enumeration, or function
with a comment starting with \emph{//\%} indicates that \MC should map the C++ construct to STS.
Within the \emph{//\%} comment, attributes are used to define the visual appearance for that
language construct, such as for the input namespace in the C++ for the CPX:
\begin{lstlisting}
//% color="#B4009E" weight=98 icon="\uf192"
namespace input {
    ...
\end{lstlisting}

Figure~\ref{fig:screenSnap}(C) shows the toolbox of API and language categories, where the
category \emph{INPUT} corresponding to the namespace \emph{input} can been seen (second
from the top).

Mapping of functions and enumerations between C++ and STS is straightforward
and performed automatically by \MC.
Here's an example of the C++ function \emph{onLightConditionChanged}
in the namespace \emph{input} that
wraps the more complex C++ needed to update the sensor and register the (Action)
handler with the underlying \CO runtime:
\begin{lstlisting}
//% block="on light %condition"
void onLightConditionChanged(LightCondition condition, Action handler) {
    auto sensor = &getWLight()->sensor;
    sensor->updateSample();
    registerWithDal(sensor->id, (int)condition, handler);
}
\end{lstlisting}

\MC uses a TypeScript declaration file (here called a shim file) to describe the TypeScript
elements corresponding to C++ namespaces, enumerations and functions.
Since the C++ function above is preceded by a \emph{//\%} comment,
\MC adds the following TypeScript declaration to the shim file and copies
over the attribute definitions in the comment. \MC also adds an attribute definition mapping
the TypeScript shim to its C++ function:

\begin{lstlisting}
//% block="on light %condition"
//% shim=input::onLightConditionChanged
function onLightConditionChanged(condition: LightCondition, handler: () => void): void;
\end{lstlisting}

Since the \emph{//\%} comment also contains a \emph{block} attribute, \MC creates a block (named ``on light''), which can be seen in the upper-left of Figure~\ref{fig:screenSnap}(D).

To support the foreign function interface, \MC defines a mapping between C++ and STS types.
Boolean and void have straightforward mappings from C++ to STS (bool $\rightarrow$ boolean, void $\rightarrow$ void).
As JavaScript only supports number, which is a C++ float/double, \MC uses TypeScript's support
for type aliases to name the various C++ integer types commonly used for MCU programming
(int32, uint32, int16, uint16, int8, uint8).
% don't use int, unsigned etc. they are actually different sizes on different compilers for AVR
This is particularly useful for saving space on 8-bit architectures such as the AVR.
\MC also includes reference counted C++ types for strings, lambdas (Action in C++, with
up to three arguments and a return type) and collections, with mappings to STS.

\MC does not yet include garbage collection, so advanced users who create cyclic
data structures must be careful to break cycles to ensure complete deallocation.

\subsection{Metadata generation}

Both C++ and TypeScript APIs can be specially annotated (minimally via
\emph{//\% block}) so that the \MC compiler generates the needed
Blockly metadata to expose an API as a visual block.
Additional attribute definitions can provide text descriptions for the block, project function
parameters (thus simplifying the API available via Blockly), and describe other visual/functional
characteristics of the block.  \MC uses the types of function parameters to select appropriate
Blockly widgets.  For example, given a C++ enumeration such as:
\begin{lstlisting}
enum class LightCondition {
    Dark = ANALOG_THRESHOLD_LOW,
    Bright = ANALOG_THRESHOLD_HIGH
};
\end{lstlisting}
a parameter of type \emph{LightCondition}, as found in
the function \emph{onLightConditionChanged}, will use a Blockly drop-down menu
so the user can select one of the two possible values (Dark, Bright).

\MCN's support for Blockly means that for the common case, the \MC target developer doesn't need
to know anything about the Blockly framework.
For more sophisticated needs, one can directly access the Blockly framework.

\subsection{Editors}

\MC uses the Blockly and Monaco editors to allow the user to code with
visual blocks or STS. The editing experience is parameterized by the full-typed device
runtime, which provides a set of categorized APIs to the end-user, based on namespaces, as
previously described. These APIs are visible in both editors via a toolbox (Figure~\ref{fig:screenSnap}(C)) to the immediate left of the programming area.

\MC compiles the Blockly program representation to STS in a syntax-directed manner.
A key issue is the need for type inference on the Blockly representation, as variables generally are defined and used without
being declared in Blockly. \MC uses a simple unification type inference to assign a
unique type to each variable.
STS supports programming constructs that are not available in Blockly, such as classes.
Such constructs are converted into grey uneditable blocks in Blockly, with the construct's program
text intact. This means \MC always can decompile an error-free STS program to Blockly and then recover
the program text of the grey blocks when converting from Blockly back to STS.

\subsection{Browser compilation}

When a user requests a download of the compiled binary, \MC first invokes the TypeScript language service to perform type inference and type checking on the
user's program, the device runtime written in STS, as well as the TypeScript declarations
corresponding to the C++ device runtime. It then checks that the
combined TypeScript program is within the STS subset through additional syntactic and type checks over the typed AST (detailed in Section~\ref{sec:sts}).  Assuming all the
above checks pass, \MC then performs tree shaking of the AST to remove unused functions.
The reduced AST then is compiled to an intermediate representation (IR) that makes explicit: labelled control
flow among a sequence of instructions with conditional and unconditional jumps; heap cells; field accesses; store operations,
and reference counting.

There are three backends for code generation from the IR. The first backend generates JavaScript,
for execution against the simulator runtime.  A second backend generates assembler, parameterized by a
processor description.  Currently supported processors include ARM's Cortex class (Thumb instructions)
and Atmel's ATmega class (AVR instructions). A separate assembler, also parameterized by an instruction
encoder/decoder, generates machine code and resolves runtime references, producing a final binary executable. A third backend generates bytecode instructions.
\MC can encode the resulting binary in several formats,
including Intel's HEX format~\cite{IntelHEX} and the \UF format (created by
the authors for faster device flashing) documented in the Appendix (Section~\ref{sec:uf2}).

\subsubsection{Asynchronous Functions}

% TOM: CONTEXT?

An important part of the compilation process is to allow users to call asynchronous
STS functions (identified through the \emph{//\% async} annotation)
as if they were blocking functions.  For example, in Figure~\ref{fig:example}, the runtime
function \emph{loops.pause(1000)} (called at line 10)
is an async function that sets a countdown timer (for 1000 milliseconds)
and then yields to the scheduler. When the timer
reaches zero, the function continuation is queued for execution.

For execution in the single-threaded context of the JavaScript runtime,
every function is compiled so that it can be suspended (at the return of a call) and later resumed (at the same point).
The default behavior at a suspension point is to immediately resume execution.  For a call to an async function,
the default behavior is overridden by the compiler, which suspends execution of the current function.
Upon completion of the async function call, the current function then is resumed.
The \CO device runtime supports fibers with the ability to yield, so for compilation to a device,
the compiler simply emits a call to yield at a suspension point.

Async functions are written by runtime developers, not end-users, and greatly simplify the JavaScript
programming model for end-users. For example, although the JavaScript simulator runtime uses promises to
achieve asynchronous execution in a single-threaded context, these promises are hidden from the end user.

\subsubsection{Untagged and Tagged Strategies}\label{sec:untagged-tagged}

The \MC compiler supports the STS language subset of TypeScript described in Section~\ref{sec:sts},
with two compilation strategies: untagged and tagged. Under the untagged strategy,
a JavaScript number is interpreted as a C++ \texttt{int} by default and the type system is used
to statically distinguish primitive values from boxed values. As a result, the untagged
strategy is not fully faithful to JavaScript semantics: there is no support for floating
point and the \texttt{null} and \texttt{undefined} values are represented by the default integer value of zero. The untagged strategy is used for the micro:bit and Arduino Uno targets.

In the tagged strategy, numbers are either tagged 31-bit signed integers, or if they do not fit,
boxed doubles. Special constants like \texttt{false}, \texttt{null} and \texttt{undefined} are given special values
and can be distinguished. The tagged execution strategy has the capability to fully support
JavaScript semantics. This strategy is used for all SAMD21 targets, including the CPX.

% TOM: WHY ARE ARE THE UNTAGGED STATEGIES USED FOR MB AND UNO, AND TAGGED USED FOR CPLAY? MORE CONTEXT REQUIRED.

\subsection{Simulator}

A \MC target can provide an alternate implementation for each API in the device runtime, for use in the device
simulator. As this code runs in the web browser (not on the actual device) and manipulates the DOM, the developer is free to
use all of TypeScript/JavaScript's features.

As shown in Figure~\ref{fig:screenSnap}(B), the simulator allows the user to experience the basic functions of the device
in the browser and to test their code
before deploying it to the actual device. The simulator has proxy widgets for sensors such as the
light detector, temperature and accelerometer, allowing the user to control the sensor's value.
