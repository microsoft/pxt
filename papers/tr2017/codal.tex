\section{The CODAL Runtime}
\label{sec:codal}

\emph{TBALL comment: the main focus on CODAL here is the support for event based programming with concurrrent handlers,
   providing the bridge between scripting languages such as JavaScript and the world of microcontrollers. }

\emph{TBALL comment: a second focus, also important, is how CODAL is architected to support multiple boards}

For reasons of efficiency and ease of access to hardware, code for microcontrollers is typically written in C and/or C++. 
However, this still leaves the programming model undefined. The Arduino programming model is based on polling: 
an Arduino ``sketch'' is a program template that consists of a setup procedure, for initialization of data structures,
and a loop procedure; programmers implement the body of setup and loop, where they explicitly poll the state of the
microcontrollerâ€™s pins. The Arduino model emphasizes sequential composition, which is not well-suited to reactive
systems where event arrival is unpredictable, and events must be handled quickly to achieve responsiveness.

The component-oriented device abstraction layer (CODAL) presents a programming model consisting of a set of
components that abstract away microcontroller details (such as pins and whether one polls or uses interrupts)
and communicate via events using a publish/subscribe mechanism.  Components can schedule event handlers to run
concurrently using a non-preemptive fiber scheduler. Each software component abstracts a hardware feature, sensor,
or connected device. \emph{TODO: how CODAL handles responsiveness?}

The CODAL runtime provides higher-level abstractions to the compiler developer, making it
easy to compile event based mechanisms, such as found in scripting languages like JavaScript, to the world of the
microcontroller.   The CODAL runtime has several layers:
\begin{itemize}

\item \emph{Core Abstractions}:
\emph{\href{https://www.github.com/lancaster-university/codal-core}{codal-core}} defines the base classes for
components, eventing, scheduling and processor/platform independent driver abstractions (for example,
\emph{LinearAnalogSensor}, given an input range and an output range for an analog pin, automatically scales sampled data 
from that pin into the given output range);

\item \emph{Platform/device-specific} implementations and optimizations are defined in separate repos. For example, 
\emph{\href{https://www.github.com/lancaster-university/codal-mbed}{codal-mbed}}
provides Mbed-specific implementations of CODAL abstractions of pins, timers, as well as serial and I2C
communications. Further specialization of this repo for the SAMD21 microcontroller is provided by 
\emph{\href{https://www.github.com/lancaster-university/codal-samd21-mbed}{codal-samd21-mbed}}. 
This repo also includes device-specific code for the Adafruit Circuit Playground Express (see CIRCUIT\_PLAYGROUND
directory).

\end{itemize}

% \emph{Build shell}:~\href{https://www.github.com/lancaster-university/codal}{lancaster-university/codal};

\subsection{Core Abstractions}

\subsubsection{System Components}

% Timer
% Pin
% Heap Allocator
% USB
% Logging
% Fibers and Scheduler


\subsubsection{Device Components}

% higher-level abstractions than GPIO 

% #define DEVICE_ID_BUTTON_A            1                         // IDs used by commonly used components. Used by convention.
% #define DEVICE_ID_BUTTON_B            2
% #define DEVICE_ID_BUTTON_AB           3
% #define DEVICE_ID_BUTTON_RESET        4
% #define DEVICE_ID_ACCELEROMETER       5
% #define DEVICE_ID_COMPASS             6
% #define DEVICE_ID_DISPLAY             7
% #define DEVICE_ID_THERMOMETER         8
% #define DEVICE_ID_RADIO               9
% #define DEVICE_ID_RADIO_DATA_READY    10
% #define DEVICE_ID_MULTIBUTTON_ATTACH  11
% #define DEVICE_ID_SERIAL              12
% #define DEVICE_ID_GESTURE             13
% #define DEVICE_ID_SYSTEM_TIMER        14
% #define DEVICE_ID_SCHEDULER           15
% #define DEVICE_ID_COMPONENT           16
% #define DEVICE_ID_LIGHT_SENSOR        17
% #define DEVICE_ID_TOUCH_SENSOR        18
% #define DEVICE_ID_SYSTEM_DAC          19
% #define DEVICE_ID_SYSTEM_MICROPHONE   20
% #define DEVICE_ID_SYSTEM_LEVEL_DETECTOR 21

\subsubsection{Events and the Message Bus}

\emph{TODO - CodalComponent: software model of device driver (physical and logical); components requiring periodic invocation}

A message bus enables a simple but powerful eventing model. Every runtime component has its own namespace for events
which can be raised at any time. Users may register event handlers for any number of such events. Moreover, event handlers
are transparently run in their own fiber - providing decoupling of user code from system code, device drivers and interrupts.
Fibers may also block awaiting events---a simple yet effective condition synchronisation mechanism.

\subsubsection{Fiber Scheduler}

A fiber scheduler enables a degree of managed concurrency on the device. Many high level languages require asynchronous
execution for responsiveness. Support for these languages can be greatly simplified through the presence of a scheduler. 
The scheduler is, by design, non-preemptive to minimize race conditions and interleaving of user code. This is also informed
by recent studies of concurrency in visual programming languages \cite{meerbaum2013learning}. A further benefit of running a 
scheduler is that when no user code needs to be executed, the device can safely be put into a power efficient sleep mode,
transparently to the user.

\subsubsection{CodalDevice}

\emph{Putting it all together}


\subsection{Processor}

\subsubsection{SAMD21}
