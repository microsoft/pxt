\section{Related Work}
\label{sec:related}

Related work breaks into four parts: the programming of microcontrollers, 
type systems for JavaScript, operating systems
for microcontrollers, and techniques for code loading.

\subsection{Programming microcontrollers}

There are four basic paradigms for programming microcontrollers:
\begin{itemize}
\item a binary for the microcontroller is compiled on a host computer and loaded onto the microcontroller -
this is the common paradigm for Arduino~\cite{buildingArduino2014};
\item bytecode for interpretation on the microcontoller is compiled on host and loaded onto microcontroller - 
this is the common paradigm for Java for embedded systems~\cite{ClausenTOPLAS};
\item a complete REPL, compiler and runtime are put on microcontroller, as 
with MicroPython~\cite{MicroPython};
\item a program executing on a host computer sends commands to a fixed program loaded onto the
microcontroller, either over a wired connection (USB serial, for example) or a radio network
(Bluetooth, for example) - this paradigm is used by Scratch~\cite{ScratchCACM2009};
\end{itemize}

\emph{\MC supports both native compilation and bytecode generation.}

\begin{itemize}
\item While the Arduino IDE recently 
has been ported to the web, it lacks basic features of modern IDEs (such as intellisense) 
and needs a connection to a server to invoke a C/C++ compiler on user code;
\item scratch and scratch extensions (provide tethered mode for microcontrollers)
\end{itemize}

\subsection{Types for JavaScript}

By design, TypeScript does not provide a soundness guarantee (though see Conjecture XYZ)~\cite{BiermanAT14}.
Type systems with soundness guarantees for JavaScript have as their
goals: (1) handling arbitrary JavaScript programs; (2) XYZ.
Safe TypeScript~\cite{SafeTypeScript15}: distinguishes dynamic from Any type - dynamic means
one of the known static types, where as Any denotes types coming
from raw JavaScript.
StrongScript~\cite{StrongScriptECOOP15}.

Static TypeScript differs from these efforts by outlawing untyped or optionally typed
code; \emph{it is non-goal to support arbitrary JavaScript programs}.
In this sense, it can be seen to be StrongScript where every variable and 
expression has a concrete (!) type.   As in StrongScript, classes are nominally typed,
which permits a more efficient and traditional property lookup for class instances. 
Static TypeScript goes further by outlawing downcasts (for untagged implementation).

\subsection{Operating systems}

Typically written in C and/or C++, platforms for microcontroller programming all share 
a common design goal: to support developers by providing primitives and programming 
abstractions. Platforms can range from simple C++ classes that control hardware, 
to real-time operating systems (RTOSs) with scheduling and memory management.

The Arduino ecosystem is an example of a simple platform where the developer uses 
high-level APIs to control hardware; there is no scheduler, and memory management 
is discouraged through a heavy emphasis on global variables.  The Arduino programming 
model is based on polling: an Arduino ``sketch'' is a program template that consists 
of a setup procedure, for initialization of data structures, and a loop procedure; 
programmers implement the body of \textit{setup} and \textit{loop}, where they explicitly 
poll the state of the sensors or the microcontroller's pins.

At the other end of the spectrum is mbed OS, which is aimed at developers who are familiar 
with non-preemptive scheduling, memory management, and condition synchronisation; a more 
complex environment. A number of high-level drivers are provided and the programming model 
is determined by the developer, commonly event or interrupt driven.

Although platforms like Arduino and mbed OS are widely used by C/C++ developers, 
higher-level languages opt for virtual machines to execute on microcontrollers 
as neither extreme aligns with the programming models seen in higher level languages: 
mbed OS is pre-emptive, JavaScript is not; Arduino is based on monolithic polling. 

The goals of CODAL are to: (1) bridge the semantic gap between 
higher-level languages and the hardware in a memory, energy and instruction 
efficient way; and (2) support a number of platforms with various
resource contraints and capabilities.

Unlike mbed, which is designed to make all devices look programmatically alike,
CODAL enables devices with additional on-chip hardware to specialise device drivers 
with APIs that can then be used by the end application developer.

% https://state-machine.com/arduino/ 
% http://tinyos.stanford.edu/tinyos-wiki/index.php/TinyOS_Overview 

% Tethered modes: Kodu for micro:bit, Scratch for micro:bit. The PC is central, the microcontroller is peripheral
% Virtual machines: MicroPython, ev3, littlebits, etc.
% Raspberry Pi: complete operating system

\subsection{Code loading}

One solution would be to rely on emerging standards, like WebUSB and WebBluetooth to transfer a program from the browser 
to the microcontroller. These standards are however still in their infancy, and it may take even longer before they are 
deployed in schools.

DAPLink must solve the following problem: it sees a 512 byte block of data to be written
at a particular block index on the device and must decide if it's part of the file being flashed and, if so, extract
the data and write it to the target microcontroller. Furthermore, when the OS writes a HEX file, DAPLink needs to discard
writes to the FAT or directory table, as well as writes of the meta-data files, and may need to deal with out-of-order writes.

Intel's HEX file format doesn't give us these properties 
- the 512 byte boundary can be in the middle of a line in the HEX file, 
and even if we have an entire line, every line only
contains the last 16 bits of the address where to flash, 
with the upper 16 supplied only when they change.

As a result, DAPLink is quite complex and sometimes needs to be updated when a new OS release changes the way
in which it handles FAT. 
This also is the reason that some MSC bootloaders for various chips only support given operating
systems under specific conditions.


% ARM solution