\section{USB Flashing Format}
\label{sec:uf2}

The way that code gets from a host computer onto a microcontroller is deeply rooted in 1980's technologies - 
serial wires, obscure protocols, and textual file formats with restricted line length. Depending on exact circumstances,
one must install serial USB drivers, select the right port and parameters, and use a native application to access
the microcontroller. As the advance of maker content in educational curricula continues,
this complicated flashing process presents one of the major obstacles to adoption in schools, 
where installing any software is usually the domain of IT administrators.

ARM created a solution with its DAPLink firmware: a USB-capable microcontroller presents itself 
to an external computer as a USB pen drive. No special drivers need to be installed, as operating systems support pen
drives out of the box, typically formatted using FAT. The USB pen drive protocol (Mass Storage Class or MSC) is a
block-level protocol (generally 512 bytes) with no concept of files. 

DAPLink exposes a small virtual FAT file system, which
never changes due to OS writes - it has an informational text file and HTML file. 
Otherwise, the FAT and the root directory table are empty. When the OS tries to read a block,
DAPLink computes what should be there, 
based on compiled-in contents of the info and HTML files.
On file system writes, DAPLink detects the Intel HEX format~\cite{IntelHEX}, 
decodes it and flashes the file's contents into the target microcontroller's memory. 

If every 512 block of the file being flashed was easy to distinguish from meta-data
or other random files, and easy to act on, independent of other blocks, DAPlink's
task would be made much easier., Unfortunately, as discussed in related work, 
the Intel HEX format does not have this property, which results in extra complexity
in the DAPlink code and fragility with respect to operating system differences with
respect to FAT. 

% A UF2 file consists of 512 byte blocks. Each block starts with a 32 byte header, 
% followed by data, and a final magic number. 
% All fields, except for data, are 32 bit unsigned little endian integers.
%
% Offset	Size	Value
% 0	4	First magic number, 0x0A324655 ("UF2\n")
% 4	4	Second magic number, 0x9E5D5157
% 8	4	Flags
% 12	4	Address in flash where the data should be written
% 16	4	Number of bytes used in data (often 256)
% 20	4	Sequential block number; starts at 0
% 24	4	Total number of blocks in file
% 28	4	File size or reserved (write as zero)
% 32	476	Data, padded with zeros
% 508	4	Final magic number, 0x0AB16F30

For these reasons, we designed the USB Flashing Format (UF2). It consists of 512 byte blocks, where each block contains:
\begin{itemize}
\item two ``magic'' numbers at the beginning and one at the end of the block,
to heuristically distinguish it from any other blocks that the OS writes;
\item the address in the target chip flash memory where the payload should be written;
\item total number of blocks in the file and the sequential index of the current block;
\item the payload data (up to 476 bytes)
\end{itemize}
A detailed description of the format can be found at~\emph{\href{https://github.com/microsoft/uf2}{uf2}}.
The format is designed specifically to deal with the following problems:
\begin{itemize}
\item operating system (OS) writes of blocks in different order than occurs in a file;
\item OS writes of blocks multiple times;
\item OS writes of data that is not a UF2 block;
\item OS writes of partial blocks (first/final part of a block), possibly for metadata detection or search indexing.
\end{itemize}

The first magic number is \texttt{UF2}, making easy to identify UF2 blocks in a text editor.
The second and final magic numbers were randomly selected.
The magic number at the end of the block helps to mitigate partial block writes.
The UF2 header is padded to 32 bytes, as hex editors commonly use 16 or 32 bytes as line length. 
This way, the data payload is aligned to line start. 32 bit integers are used for all fields so that 
large flash sizes can be supported in future, as well as for simplicity.
Little endian is used, as most microcontrollers are little endian. 
The total number of blocks in the file and the sequential block number make it easy 
bootloaders to detect that all blocks have been transferred, requiring just one bit of 
memory per block (eg., on SAMD21G18A it's 128 bytes).

The only file system assumption we make is that blocks of file are aligned with blocks on the hard drive. 
We also assume that USB MSC device reports its block size to be a multiple of 512 bytes. 
In the wild these devices always almost report exactly 512, and some 
operating systems do not support other values.

Target chips usually can only write their flash in chunks larger than page size. On the SAMD21, pages are 64 bytes 
but need to be erased four pages at once, so the effective page size is 256 bytes. Therefore, UF2 for SAMD21 uses 
only 256 out of the 476 byte payload, so every block can written to flash straight away. This is still more 
efficient than HEX (which stores every byte as two ASCII characters and adds 20-30\% overhead). It also doesnâ€™t 
matter - the file is transferred at USB full speed (around 1MB per second), and so the limiting factor is writing 
to flash.
